\documentclass{article}
\usepackage{listings}
\usepackage[dutch]{babel}
\lstset{tabsize=4, columns=flexible, breaklines=true, numbers=left, stepnumber=1, numberstyle=\tiny, numbersep=6pt, xleftmargin=1.8em}
\lstdefinestyle{nonumbers}{numbers=none}
\lstdefinestyle{logo}{language={}}

\begin{document}
\section*{Design}
Each node runs a very basic HTTP server that listens for GET and POST requests. Requests using
other methods are silently ignored. The server then does some very basic parsing on the first line
of the request to obtain the requested cache key.

This cache key is then run through a hashing algorithm that determines which caching server is
supposed to have the cache entry for that key. An RMI call is then issued to this server to
get the value of the cache key if the request method was GET, or to set it to the contents
of the request body if the request method was POST.

The remote server receiving this RMI call (which may or may not be the same server that
handled the HTTP request; this is handled completely transparently) has an in-memory
key-value store. For a set call, it writes the provided key-value pair to the store,
overwriting a pre-existing pair with the same key, if present. For a get call, it
retrieves the key-value pair with the provided key from the store and returns its
value.

After the RMI call finishes, the HTTP server returns the requested value for a GET
request, or an empty response for a POST request.

\section*{Implementation}
\subsection*{HTTP request format}
The requests the HTTP server expects are very simple. When getting the value of a
cache key, the following HTTP request-response dialog happens:

\begin{lstlisting}
GET /mykey HTTP/1.0

HTTP/1.0 200 OK 
Date: Mon, 11 Apr, 2011 16:56:04 CEST
Content-Type: text/plain; charset=utf-8
Content-Length: 12
Connection: close

Hello World!
\end{lstlisting}

\end{document}
